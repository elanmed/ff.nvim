*ff.txt*                                        Last change: 2025 September 09

==============================================================================
Table of Contents                                       *ff-table-of-contents*

Status ........................................................... |ff-status|
Performance ................................................. |ff-performance|
Configuration example ............................. |ff-configuration-example|
API ................................................................. |ff-api|
`setup` ........................................................... |ff-setup|
`find` ............................................................. |ff-find|
`refresh_files_cache` ............................... |ff-refresh_files_cache|
`ff.nvim` as a backend for another pick  |ff-ff.nvim`-as-a-backend-for-another-pick|
`get_weighted_files` ................................. |ff-get_weighted_files|
`refresh_frecency_cache` ......................... |ff-refresh_frecency_cache|
`refresh_open_buffers_cache` ................. |ff-refresh_open_buffers_cache|
`benchmark_mean_start` ............................. |ff-benchmark_mean_start|
`benchmark_mean_end` ................................. |ff-benchmark_mean_end|
Highlight Groups ....................................... |ff-highlight-groups|
Deps ............................................................... |ff-deps|
TODO ............................................................... |ff-todo|
Features excluded for simplicity ....... |ff-features-excluded-for-simplicity|
Similar plugins ......................................... |ff-similar-plugins|

==============================================================================
`FF.NVIM`                                                         *ff-ff.nvim*


A small, fast fuzzy finder with intelligent weights.

- **Small**: ~1100 LOC, 1 source file, 1 test file
- **Fast**: Average ~20ms per keystroke on a codebase of 60k files
- **Fuzzy**: Uses `fzy-lua-native` to fuzzy match against the current input
- **Intelligent weights**: Sorts the results by considering: - Open buffers -
  Modified buffers - The alternate buffer - The current buffer - The frecency
  (frequent + recently opened) score of a result - The basename of a result
  (with and without an extension) - The fuzzy score of a result

------------------------------------------------------------------------------
STATUS                                                             *ff-status*


- Works fine, API is not yet stable

------------------------------------------------------------------------------
PERFORMANCE                                                   *ff-performance*


`ff.nvim` prioritizes performance in a few ways:

- Files are weighted and sorted in batches w/coroutines to avoid blocking the
  picker UI
- A max of `opts.max_results_considered` files with a fuzzy match are
  processed - Frecent files are checked for a fuzzy match first, then files
  from `fd` - For empty inputs, a max of `opts.max_results_rendered` files are
  processed
- Extensive caching: - `fd` is executed once and cached when `setup` is called
  - Frecency scores are calculated once and cached when `find` is called -
  Info on open buffers are pulled once and cached when `find` is called -
  Icons are cached by extension to avoid calling `mini.icons` when possible -
  Results are cached for each user input
- A max of `opts.max_results_rendered` results are rendered in the results
  window, preventing unecessary highlighting
- Icons and highlights can be disabled for especially large codebases
With these optimizations in place, I average around 20ms per keystroke on a
codebase of 60k files. Enable the `benchmark_step` and `benchmark_mean`
options to try yourself


------------------------------------------------------------------------------
CONFIGURATION EXAMPLE                               *ff-configuration-example*


>lua
    local ff = require "ff"
    ff.setup {
      -- defaults to:
      refresh_files_cache = "setup",
      benchmark_step = false,
      benchmark_mean = false,
      fd_cmd = "fd --absolute-path --hidden --type f --exclude .git",
    }
    
    local editor_height = vim.o.lines - 1
    local input_height = 1
    local border_height = 2
    local available_height = editor_height - input_height - (border_height * 3)
    local results_height = math.floor(available_height / 2)
    local input_row = editor_height
    local results_row = input_row - input_height - border_height
    
    vim.keymap.set("n", "<leader>f", function()
      ff.find {
        -- no keymaps are set by default
        keymaps = {
          i = {
            ["<cr>"] = "select",
            ["<c-n>"] = "next",
            ["<c-p>"] = "prev",
            ["<c-c>"] = "close",
            ["<esc>"] = "close",
            ["<tab>"] = "preview-toggle",
            ["<C-d>"] = "preview-scroll-down",
            ["<C-u>"] = "preview-scroll-up",
          },
        },
        -- defaults to:
        weights = {
          open_buf_boost = 10,
          modified_buf_boost = 20,
          alternate_buf_boost = 30,
          basename_boost = 40,
          current_buf_boost = -1000,
        },
        batch_size = 250,
        icons_enabled = true,
        hi_enabled = true,
        fuzzy_score_multiple = 0.7,
        file_score_multiple = 0.3,
        max_results_considered = 1000,
        max_results_rendered = results_height * 2,
        input_win_config = {
          style = "minimal",
          anchor = "SW",
          relative = "editor",
          width = vim.o.columns,
          height = 1,
          row = input_row,
          col = 0,
          border = "rounded",
          title = "Input",
        },
        results_win_config = {
          style = "minimal",
          anchor = "SW",
          relative = "editor",
          width = vim.o.columns,
          height = results_height,
          row = results_row,
          col = 0,
          border = "rounded",
          title = "Results",
          focusable = false,
        },
        results_win_opts = {},
        preview_win_opts = {},
        on_picker_open = function(on_picker_open_opts) end
      }
    end)
<

------------------------------------------------------------------------------
API                                                                   *ff-api*



                                                                              
`SETUP`                                                             *ff-setup*

>lua
    --- @class SetupOpts
    --- @field refresh_files_cache? "setup"|"find"
    --- @field benchmark_step? boolean benchmark each keystroke
    --- @field benchmark_mean? boolean benchmark the mean of all keystrokes in a session
    --- @field fd_cmd? string
    
    --- @param opts? SetupOpts
    M.setup = function(opts) end
<

                                                                              
`FIND`                                                               *ff-find*

>lua
    --- @class FindOpts
    --- @field keymaps? FindKeymapsPerMode
    --- @field weights? FindWeights
    --- @field batch_size? number | false `false` to disable coroutines
    --- @field hi_enabled? boolean highlighting the fuzzy matched characters
    --- @field icons_enabled? boolean
    --- @field fuzzy_score_multiple? number how much to weight the fuzzy match score vs the frecency + other weights
    --- @field file_score_multiple? number how much to weight the frecency + other weights
    --- @field max_results_considered? number a max of `max_results_considered` files with a fuzzy match are sorted
    --- @field max_results_rendered? number a max of `max_results_rendered` sorted files are rendered in the results buffer
    --- @field input_win_config? vim.api.keyset.win_config
    --- @field results_win_config? vim.api.keyset.win_config
    --- @field results_win_opts? vim.wo
    --- @field preview_win_opts? vim.wo
    --- @field on_picker_open? fun(opts:OnPickerOpenOpts):nil
    
    --- @class OnPickerOpenOpts
    --- @field results_win number
    --- @field results_buf number
    --- @field input_win number
    --- @field input_buf number
    
    --- @class FindWeights
    --- @field open_buf_boost? number
    --- @field modified_buf_boost? number
    --- @field alternate_buf_boost? number
    --- @field current_buf_boost? number
    --- @field basename_boost? number
    
    --- @class FindKeymapsPerMode
    --- @field i? FindKeymaps
    --- @field n? FindKeymaps
    
    --- @class FindKeymaps
    --- @field [string] "select"|"next"|"prev"|"close"|function
    
    --- @param opts? FindOpts
    M.find = function(opts) end
<

                                                                              
`REFRESH_FILES_CACHE`                                 *ff-refresh_files_cache*

>lua
    --- @param fd_cmd string
    M.refresh_files_cache = function(fd_cmd) end
<
By default, `refresh_files_cache` is called once when `setup` is run. When
performing actions on the file system, it can be helpful to refresh the cache
so the picker shows the latest files. This can be done with an autocommand
like:

>lua
    vim.api.nvim_create_autocmd("User", {
      pattern = {
        "MiniFilesActionCreate",
        "MiniFilesActionDelete",
        "MiniFilesActionRename",
        "MiniFilesActionCopy",
        "MiniFilesActionMove",
      },
      callback = function()
        ff.refresh_files_cache()
      end,
    })
<

------------------------------------------------------------------------------
`FF.NVIM` AS A BACKEND FOR ANOTHER PICK*ff-ff.nvim`-as-a-backend-for-another-pick*


To use another picker as a frontend for `ff.nvim`, the following functions may
be useful. When calling `find` directly, there's no need to call any of these.

>lua
    vim.keymap.set("n", "<leader>ff", function()
      -- setup still needs to be called
      local curr_bufname = vim.api.nvim_buf_get_name(0)
      local alt_bufname = vim.api.nvim_buf_get_name(vim.fn.bufnr "#")
    
      local ff = require "ff"
      ff.benchmark_mean_start()
      ff.refresh_frecency_cache()
      ff.refresh_open_buffers_cache()
    
      vim.ui.input({ prompt = "ff> ", }, function(query)
        query = query or ""
        local weighted_files = ff.get_weighted_files {
          query = query,
          curr_bufname = curr_bufname, -- defaults to "" if not passed
          alt_bufname = alt_bufname, -- defaults to "" if not passed
          -- defaults to:
          weights = {
            open_buf_boost = 10,
            modified_buf_boost = 20,
            alternate_buf_boost = 30,
            basename_boost = 40,
            current_buf_boost = -1000,
          },
          batch_size = false, -- `false` disables calling `coroutine.yield()`
          icons_enabled = true,
          hi_enabled = true,
          fuzzy_score_multiple = 0.7,
          file_score_multiple = 0.3,
          max_results_considered = 1000,
          max_results_rendered = 50,
        }
        local lines = vim.tbl_map(function(weighted_file) return weighted_file.formatted_filename end, weighted_files)
    
        vim.cmd "vnew"
        vim.bo.buftype = "nofile"
        vim.bo.bufhidden = "wipe"
        vim.api.nvim_buf_set_lines(0, 0, -1, false, lines)
      end)
    
      -- this should be in an `on_close` function
      ff.benchmark_mean_end()
    end)
<

                                                                              
`GET_WEIGHTED_FILES`                                   *ff-get_weighted_files*

>lua
    --- @class WeightedFile
    --- @field abs_file string
    --- @field rel_file string
    --- @field weighted_score number fuzzy_score_multiple * fuzzy_score + file_score_multiple * buf_and_frecency_score
    --- @field fuzzy_score number
    --- @field buf_and_frecency_score number
    --- @field hl_idxs table the indexes of the `rel_file` that are fuzzy matched
    --- @field icon_char string
    --- @field icon_hl string
    --- @field formatted_filename string
    
    --- @class GetWeightedFilesOpts
    --- @field query string
    --- @field curr_bufname string absolute path of the current buffer
    --- @field alt_bufname string absolute path of the alternate buffer
    --- @field weights Weights
    --- @field batch_size number | false
    --- @field hi_enabled? boolean `false` will set `hl_idxs` to `{}`
    --- @field icons_enabled boolean
    --- @field max_results_considered? number a max of `max_results_considered` files with a fuzzy match are sorted
    --- @field max_results_rendered? number a max of `max_results_rendered` sorted files are rendered in the results buffer
    --- @field fuzzy_score_multiple? number how much to weight the fuzzy match score vs the frecency + other weights
    --- @field file_score_multiple? number how much to weight the frecency + other weights
    
    --- @param opts GetWeightedFilesOpts
    --- @return WeightedFile[]
    M.get_weighted_files = function(opts) end
<

                                                                              
`REFRESH_FRECENCY_CACHE`                           *ff-refresh_frecency_cache*

>lua
    M.refresh_frecency_cache = function() end
<

                                                                              
`REFRESH_OPEN_BUFFERS_CACHE`                   *ff-refresh_open_buffers_cache*

>lua
    M.refresh_open_buffers_cache = function() end
<

                                                                              
`BENCHMARK_MEAN_START`                               *ff-benchmark_mean_start*

>lua
    M.benchmark_mean_start = function() end
    -- clears previous benchmarks
<

                                                                              
`BENCHMARK_MEAN_END`                                   *ff-benchmark_mean_end*

>lua
    M.benchmark_mean_end = function() end
    -- prints current benchmarks
<

------------------------------------------------------------------------------
HIGHLIGHT GROUPS                                         *ff-highlight-groups*


- `FFPickerFuzzyHighlightChar`: The chars in a result currently fuzzy matched
  - Defaults to `Search`
- `FFPickerCursorLine`: The current line in the results window - Defaults to
  `CursorLine`
  [!NOTE] The default highlight groups are set as a part of the `setup`
  function. In order to successfully override a highlight group, make sure to
  set it after calling`setup`


------------------------------------------------------------------------------
DEPS                                                                 *ff-deps*


- fzy-lua-native <https://github.com/romgrk/fzy-lua-native>
- mini.icons <https://github.com/echasnovski/mini.icons>
- `fd` <https://github.com/sharkdp/fd>

------------------------------------------------------------------------------
TODO                                                                 *ff-todo*


- [ ] Support alternatives to `mini.icons`
- [ ] Support alternatives to `fd`
- [ ] Support Windows

------------------------------------------------------------------------------
FEATURES EXCLUDED FOR SIMPLICITY         *ff-features-excluded-for-simplicity*


- Multi-select
- Shared options between `setup` and `find`

------------------------------------------------------------------------------
SIMILAR PLUGINS                                           *ff-similar-plugins*


- smart-open.nvim <https://github.com/danielfalk/smart-open.nvim>
- fff.nvim <https://github.com/dmtrKovalenko/fff.nvim>
- snacks.nvim's smart picker
  <https://github.com/folke/snacks.nvim/blob/main/docs/picker.md#smart>

vim:tw=78:ts=8:ft=help:norl: